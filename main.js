/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// core/BinderService.ts
var BinderService_exports = {};
__export(BinderService_exports, {
  BinderService: () => BinderService
});
var BinderService;
var init_BinderService = __esm({
  "core/BinderService.ts"() {
    BinderService = class {
      constructor(app) {
        this.app = app;
        this.state = {
          entries: []
        };
      }
      log(type, message, relatedFile, details) {
        const entry = {
          id: crypto.randomUUID(),
          timestamp: Date.now(),
          type,
          message,
          relatedFile,
          details
        };
        this.state.entries.unshift(entry);
        if (this.state.entries.length > 1e3) {
          this.state.entries = this.state.entries.slice(0, 1e3);
        }
      }
      getEntries() {
        return this.state.entries;
      }
      clear() {
        this.state.entries = [];
      }
    };
  }
});

// core/GroupService.ts
var GroupService_exports = {};
__export(GroupService_exports, {
  GroupService: () => GroupService
});
var import_obsidian, GroupService;
var init_GroupService = __esm({
  "core/GroupService.ts"() {
    import_obsidian = __toModule(require("obsidian"));
    GroupService = class {
      constructor(app) {
        this.app = app;
      }
      isInGroup(file, group) {
        return __async(this, null, function* () {
          const matchingFiles = yield this.getMatchingFiles(group);
          return matchingFiles.some((f) => f.path === file.path);
        });
      }
      getMatchingFiles(group) {
        return __async(this, null, function* () {
          var _a, _b, _c;
          if (!group.query || group.query.trim() === "") {
            return [];
          }
          const dataviewAPI = (_c = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b.dataview) == null ? void 0 : _c.api;
          if (!dataviewAPI) {
            console.warn("[Curator] Dataview plugin not found or API not available.");
            return [];
          }
          try {
            let dql = group.query.trim();
            if (!/^(TABLE|LIST|TASK|CALENDAR)/i.test(dql)) {
              dql = `LIST ${dql}`;
            }
            const result = yield dataviewAPI.query(dql);
            if (!result.successful) {
              console.warn(`[Curator] Dataview query failed for group ${group.name}: ${result.error}`);
              return [];
            }
            const values = result.value.values;
            const matchingFiles = [];
            for (const item of values) {
              let path;
              if (item && item.path) {
                path = item.path;
              } else if (item && item.file && item.file.path) {
                path = item.file.path;
              }
              if (path) {
                const file = this.app.vault.getAbstractFileByPath(path);
                if (file instanceof import_obsidian.TFile) {
                  matchingFiles.push(file);
                }
              }
            }
            return matchingFiles;
          } catch (error) {
            console.error(`[Curator] Error executing Dataview query for group ${group.name}:`, error);
            return [];
          }
        });
      }
      updateIdentifiers(identifiers) {
      }
    };
  }
});

// core/TriggerService.ts
var TriggerService_exports = {};
__export(TriggerService_exports, {
  TriggerService: () => TriggerService
});
var import_obsidian2, TriggerService;
var init_TriggerService = __esm({
  "core/TriggerService.ts"() {
    import_obsidian2 = __toModule(require("obsidian"));
    TriggerService = class {
      constructor(app) {
        this.listeners = new Map();
        this.eventRefs = [];
        this.activeTriggers = new Map();
        this.app = app;
      }
      registerTrigger(id, trigger, callback) {
        var _a;
        console.log(`[DEBUG] Registering trigger ${id}`);
        if (!this.listeners.has(id)) {
          this.listeners.set(id, []);
        }
        (_a = this.listeners.get(id)) == null ? void 0 : _a.push(callback);
        this.activeTriggers.set(id, trigger);
      }
      clearTriggers() {
        this.listeners.clear();
        this.activeTriggers.clear();
      }
      initializeListeners() {
        this.eventRefs.forEach((ref) => this.app.vault.offref(ref));
        this.eventRefs = [];
        this.eventRefs.push(this.app.vault.on("create", (file) => {
          if (file instanceof import_obsidian2.TFile)
            this.handleEvent("create", file);
        }));
        this.eventRefs.push(this.app.vault.on("modify", (file) => {
          if (file instanceof import_obsidian2.TFile)
            this.handleEvent("modify", file);
        }));
        this.eventRefs.push(this.app.vault.on("rename", (file, oldPath) => {
          if (file instanceof import_obsidian2.TFile)
            this.handleEvent("rename", file, oldPath);
        }));
        this.eventRefs.push(this.app.vault.on("delete", (file) => {
          if (file instanceof import_obsidian2.TFile)
            this.handleEvent("delete", file);
        }));
        this.startSyncPolling();
      }
      startSyncPolling() {
        var _a, _b;
        const syncPlugin = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b.sync;
        if (!syncPlugin || !syncPlugin.enabled)
          return;
        let lastStatus = "";
        const intervalId = window.setInterval(() => {
          const statusBarItem = document.querySelector(".status-bar-item.plugin-sync");
          if (!statusBarItem)
            return;
          const text = statusBarItem.textContent || "";
          const ariaLabel = statusBarItem.getAttribute("aria-label") || "";
          const status = text + ariaLabel;
          if (status !== lastStatus) {
            if (status.includes("Fully synced")) {
              this.handleSystemEvent("sync_finish");
            } else if (status.includes("Syncing")) {
              this.handleSystemEvent("sync_start");
            }
            lastStatus = status;
          }
        }, 2e3);
      }
      handleEvent(eventType, file, oldPath) {
        var _a;
        for (const [id, trigger] of this.activeTriggers.entries()) {
          if (trigger.type === "obsidian_event" && trigger.event === eventType) {
            this.fireTrigger(id, file);
          }
          if (trigger.type === "folder_event" && eventType === "rename" && oldPath && trigger.folder) {
            const oldFolder = oldPath.substring(0, oldPath.lastIndexOf("/"));
            const newFolder = ((_a = file.parent) == null ? void 0 : _a.path) || "";
            const targetFolder = trigger.folder;
            if (trigger.event === "enter") {
              if (oldFolder !== targetFolder && newFolder === targetFolder) {
                this.fireTrigger(id, file);
              }
            } else if (trigger.event === "leave") {
              if (oldFolder === targetFolder && newFolder !== targetFolder) {
                this.fireTrigger(id, file);
              }
            }
          }
        }
      }
      handleSystemEvent(eventType) {
        return __async(this, null, function* () {
          const files = this.app.vault.getMarkdownFiles();
          for (const [id, trigger] of this.activeTriggers.entries()) {
            if (trigger.type === "system_event" && trigger.event === eventType) {
              if (trigger.timeConstraints) {
                const now = new Date();
                if (trigger.timeConstraints.start) {
                  const start = new Date(trigger.timeConstraints.start);
                  if (now < start)
                    continue;
                }
                if (trigger.timeConstraints.end) {
                  const end = new Date(trigger.timeConstraints.end);
                  if (now > end)
                    continue;
                }
              }
              for (const file of files) {
                this.fireTrigger(id, file);
              }
            }
          }
        });
      }
      fireTrigger(triggerId, file) {
        const callbacks = this.listeners.get(triggerId);
        if (callbacks) {
          callbacks.forEach((cb) => cb(triggerId, file));
        }
      }
      unload() {
        this.eventRefs.forEach((ref) => this.app.vault.offref(ref));
        this.eventRefs = [];
        this.listeners.clear();
        this.activeTriggers.clear();
      }
    };
  }
});

// core/ActionService.ts
var ActionService_exports = {};
__export(ActionService_exports, {
  ActionService: () => ActionService
});
var import_obsidian3, ActionService;
var init_ActionService = __esm({
  "core/ActionService.ts"() {
    import_obsidian3 = __toModule(require("obsidian"));
    ActionService = class {
      constructor(app, binder) {
        this.app = app;
        this.binder = binder;
      }
      executeAction(file, action) {
        return __async(this, null, function* () {
          try {
            switch (action.type) {
              case "move":
                if (action.config.folder) {
                  yield this.moveFile(file, { folder: action.config.folder, createIfMissing: action.config.createIfMissing });
                }
                break;
              case "rename":
                yield this.renameFile(file, action.config);
                break;
              case "tag":
                if (action.config.tag) {
                  yield this.tagFile(file, { tag: action.config.tag, operation: action.config.operation || "add" });
                }
                break;
              default:
                this.binder.log("warning", `Unknown action type: ${action.type}`, file.path);
            }
          } catch (error) {
            this.binder.log("error", `Failed to execute action ${action.type}`, file.path, error);
            throw error;
          }
        });
      }
      moveFile(file, config) {
        return __async(this, null, function* () {
          let targetFolder = (0, import_obsidian3.normalizePath)(config.folder);
          const folderExists = yield this.app.vault.adapter.exists(targetFolder);
          if (!folderExists) {
            if (config.createIfMissing) {
              yield this.app.vault.createFolder(targetFolder);
              this.binder.log("info", `Created folder ${targetFolder}`);
            } else {
              this.binder.log("error", `Target folder ${targetFolder} does not exist`, file.path);
              return;
            }
          }
          const targetPath = (0, import_obsidian3.normalizePath)(`${targetFolder}/${file.name}`);
          if (targetPath === file.path) {
            return;
          }
          const targetFileExists = yield this.app.vault.adapter.exists(targetPath);
          if (targetFileExists) {
            this.binder.log("warning", `File ${targetPath} already exists. Skipping move.`, file.path);
            return;
          }
          yield this.app.fileManager.renameFile(file, targetPath);
          this.binder.log("success", `Moved file to ${targetFolder}`, targetPath);
        });
      }
      renameFile(file, config) {
        return __async(this, null, function* () {
          var _a;
          let newName = file.basename;
          if (config.replace) {
            newName = config.replace;
          }
          if (config.prefix) {
            newName = `${config.prefix}${newName}`;
          }
          if (config.suffix) {
            newName = `${newName}${config.suffix}`;
          }
          if (newName === file.basename)
            return;
          const targetPath = (0, import_obsidian3.normalizePath)(`${(_a = file.parent) == null ? void 0 : _a.path}/${newName}.${file.extension}`);
          if (yield this.app.vault.adapter.exists(targetPath)) {
            this.binder.log("warning", `File ${targetPath} already exists. Skipping rename.`, file.path);
            return;
          }
          yield this.app.fileManager.renameFile(file, targetPath);
          this.binder.log("success", `Renamed file to ${newName}`, targetPath);
        });
      }
      tagFile(file, config) {
        return __async(this, null, function* () {
          yield this.app.fileManager.processFrontmatter(file, (frontmatter) => {
            let tags = frontmatter["tags"];
            if (!tags)
              tags = [];
            if (!Array.isArray(tags))
              tags = [tags];
            const targetTag = config.tag.startsWith("#") ? config.tag.substring(1) : config.tag;
            if (config.operation === "add") {
              if (!tags.includes(targetTag)) {
                tags.push(targetTag);
                this.binder.log("success", `Added tag #${targetTag}`, file.path);
              }
            } else if (config.operation === "remove") {
              const index = tags.indexOf(targetTag);
              if (index > -1) {
                tags.splice(index, 1);
                this.binder.log("success", `Removed tag #${targetTag}`, file.path);
              }
            }
            frontmatter["tags"] = tags;
          });
        });
      }
    };
  }
});

// core/RulesetService.ts
var RulesetService_exports = {};
__export(RulesetService_exports, {
  RulesetService: () => RulesetService
});
var RulesetService;
var init_RulesetService = __esm({
  "core/RulesetService.ts"() {
    RulesetService = class {
      constructor(app, triggerService, groupService, binder, actionService) {
        this.rulesets = [];
        this.app = app;
        this.triggerService = triggerService;
        this.groupService = groupService;
        this.binder = binder;
        this.actionService = actionService;
      }
      updateConfig(config) {
        this.rulesets = config.rulesets;
        this.triggerService.clearTriggers();
        this.rulesets.forEach((ruleset) => {
          if (ruleset.enabled && ruleset.trigger) {
            this.triggerService.registerTrigger(ruleset.id, ruleset.trigger, (triggerId, file) => {
              this.handleTrigger(triggerId, file);
            });
          }
        });
      }
      handleTrigger(rulesetId, file) {
        return __async(this, null, function* () {
          const ruleset = this.rulesets.find((r) => r.id === rulesetId);
          if (!ruleset || !ruleset.enabled)
            return;
          this.binder.log("info", `Processing Ruleset: ${ruleset.name}`, file.path);
          for (const rule of ruleset.rules) {
            let match = true;
            if (rule.query && rule.query.trim() !== "") {
              const tempGroup = { id: "temp", name: "Rule Query", query: rule.query };
              match = yield this.groupService.isInGroup(file, tempGroup);
            } else {
              match = true;
            }
            if (match) {
              this.binder.log("info", `Rule matched. Executing actions.`, file.path);
              yield this.executeActions(rule.actions, file);
            }
          }
        });
      }
      executeActions(actions, file) {
        return __async(this, null, function* () {
          for (const action of actions) {
            try {
              yield this.actionService.executeAction(file, action);
            } catch (error) {
              this.binder.log("error", `Failed to execute action ${action.type}`, file.path, error);
            }
          }
        });
      }
      dryRun(rulesetId) {
        return __async(this, null, function* () {
          const ruleset = this.rulesets.find((r) => r.id === rulesetId);
          if (!ruleset)
            return [];
          const results = [];
          const files = this.app.vault.getMarkdownFiles();
          for (const file of files) {
            const fileActions = [];
            for (const rule of ruleset.rules) {
              let match = true;
              if (rule.query && rule.query.trim() !== "") {
                const tempGroup = { id: "temp", name: "Rule Query", query: rule.query };
                match = yield this.groupService.isInGroup(file, tempGroup);
              }
              if (match) {
                for (const action of rule.actions) {
                  fileActions.push(`${action.type} ${JSON.stringify(action.config)}`);
                }
              }
            }
            if (fileActions.length > 0) {
              results.push({ file, actions: fileActions });
            }
          }
          return results;
        });
      }
    };
  }
});

// main.ts
__export(exports, {
  default: () => AutoNoteMover
});
var import_obsidian7 = __toModule(require("obsidian"));
init_BinderService();
init_GroupService();
init_TriggerService();
init_ActionService();
init_RulesetService();

// ui/CuratorSettingsTab.ts
var import_obsidian6 = __toModule(require("obsidian"));

// ui/components/RulesTab.ts
var import_obsidian4 = __toModule(require("obsidian"));
var RulesTab = class {
  constructor(app, containerEl, config, onUpdate) {
    this.app = app;
    this.containerEl = containerEl;
    this.config = config;
    this.onUpdate = onUpdate;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.createEl("h3", { text: "Rules Configuration" });
    this.containerEl.createEl("p", { text: "Connect Triggers, Groups, and Jobs to create automated workflows." });
    new import_obsidian4.Setting(this.containerEl).setName("Add New Ruleset").setDesc("Create a new rule to automate your notes.").addButton((button) => button.setButtonText("Add Ruleset").setCta().onClick(() => {
      this.addRuleset();
    }));
    const rulesetsList = this.containerEl.createDiv("rulesets-list");
    this.config.rulesets.forEach((ruleset, index) => {
      this.renderRuleset(rulesetsList, ruleset, index);
    });
  }
  renderRuleset(container, ruleset, index) {
    const rulesetContainer = container.createDiv("ruleset-container");
    rulesetContainer.style.border = "1px solid var(--background-modifier-border)";
    rulesetContainer.style.padding = "10px";
    rulesetContainer.style.marginBottom = "10px";
    rulesetContainer.style.borderRadius = "4px";
    new import_obsidian4.Setting(rulesetContainer).setName("Ruleset Name").addText((text) => text.setValue(ruleset.name).onChange((value) => {
      ruleset.name = value;
      this.onUpdate(this.config);
    })).addToggle((toggle) => toggle.setValue(ruleset.enabled).setTooltip("Enable/Disable Ruleset").onChange((value) => {
      ruleset.enabled = value;
      this.onUpdate(this.config);
    })).addExtraButton((btn) => btn.setIcon("trash").setTooltip("Delete Ruleset").onClick(() => {
      this.config.rulesets.splice(index, 1);
      this.onUpdate(this.config);
      this.display();
    }));
    const triggerDiv = rulesetContainer.createDiv("trigger-config");
    triggerDiv.style.marginBottom = "10px";
    triggerDiv.style.padding = "10px";
    triggerDiv.style.backgroundColor = "var(--background-primary-alt)";
    triggerDiv.style.borderRadius = "4px";
    new import_obsidian4.Setting(triggerDiv).setName("Trigger Type").addDropdown((dropdown) => dropdown.addOption("obsidian_event", "Obsidian Event").addOption("system_event", "System Event").addOption("folder_event", "Folder Event").addOption("manual", "Manual").setValue(ruleset.trigger.type).onChange((value) => {
      ruleset.trigger.type = value;
      if (ruleset.trigger.type === "system_event")
        ruleset.trigger.event = "startup";
      else if (ruleset.trigger.type === "folder_event")
        ruleset.trigger.event = "enter";
      else if (ruleset.trigger.type === "obsidian_event")
        ruleset.trigger.event = "modify";
      this.onUpdate(this.config);
      this.display();
    }));
    if (ruleset.trigger.type === "obsidian_event") {
      new import_obsidian4.Setting(triggerDiv).setName("Event").addDropdown((dropdown) => dropdown.addOption("create", "File Created").addOption("modify", "File Modified").addOption("rename", "File Renamed").addOption("delete", "File Deleted").setValue(ruleset.trigger.event || "modify").onChange((value) => {
        ruleset.trigger.event = value;
        this.onUpdate(this.config);
      }));
    } else if (ruleset.trigger.type === "system_event") {
      new import_obsidian4.Setting(triggerDiv).setName("Event").addDropdown((dropdown) => dropdown.addOption("startup", "Obsidian Starts").addOption("sync_start", "Sync Starts").addOption("sync_finish", "Sync Finishes").setValue(ruleset.trigger.event || "startup").onChange((value) => {
        ruleset.trigger.event = value;
        this.onUpdate(this.config);
      }));
    } else if (ruleset.trigger.type === "folder_event") {
      new import_obsidian4.Setting(triggerDiv).setName("Event").addDropdown((dropdown) => dropdown.addOption("enter", "File Entered Folder").addOption("leave", "File Left Folder").setValue(ruleset.trigger.event || "enter").onChange((value) => {
        ruleset.trigger.event = value;
        this.onUpdate(this.config);
      }));
      new import_obsidian4.Setting(triggerDiv).setName("Target Folder").addText((text) => text.setPlaceholder("folder/path").setValue(ruleset.trigger.folder || "").onChange((value) => {
        ruleset.trigger.folder = value;
        this.onUpdate(this.config);
      }));
    }
    new import_obsidian4.Setting(rulesetContainer).addButton((btn) => btn.setButtonText("Test Run (Dry Run)").setTooltip("Simulate this ruleset on all files to see what would happen.").onClick(() => __async(this, null, function* () {
      const { RulesetService: RulesetService2 } = yield Promise.resolve().then(() => (init_RulesetService(), RulesetService_exports));
      const { GroupService: GroupService2 } = yield Promise.resolve().then(() => (init_GroupService(), GroupService_exports));
      const { TriggerService: TriggerService2 } = yield Promise.resolve().then(() => (init_TriggerService(), TriggerService_exports));
      const { BinderService: BinderService2 } = yield Promise.resolve().then(() => (init_BinderService(), BinderService_exports));
      const { ActionService: ActionService2 } = yield Promise.resolve().then(() => (init_ActionService(), ActionService_exports));
      const binder = new BinderService2(this.app);
      const groupService = new GroupService2(this.app);
      const triggerService = new TriggerService2(this.app);
      const actionService = new ActionService2(this.app, binder);
      const rulesetService = new RulesetService2(this.app, triggerService, groupService, binder, actionService);
      rulesetService.updateConfig(this.config);
      const results = yield rulesetService.dryRun(ruleset.id);
      const modal = new import_obsidian4.Modal(this.app);
      modal.titleEl.setText(`Dry Run: ${ruleset.name}`);
      if (results.length === 0) {
        modal.contentEl.createEl("p", { text: "No files matched the criteria." });
      } else {
        modal.contentEl.createEl("p", { text: `Found ${results.length} matches:` });
        const list = modal.contentEl.createEl("div");
        list.style.maxHeight = "400px";
        list.style.overflowY = "auto";
        results.forEach((r) => {
          const item = list.createDiv();
          item.style.marginBottom = "5px";
          item.style.borderBottom = "1px solid var(--background-modifier-border)";
          item.createEl("strong", { text: r.file.path });
          const actionsList = item.createEl("ul");
          r.actions.forEach((a) => actionsList.createEl("li", { text: `Action: ${a}` }));
        });
      }
      modal.open();
    })));
    const rulesContainer = rulesetContainer.createDiv("rules-container");
    rulesContainer.style.marginTop = "10px";
    rulesContainer.style.paddingLeft = "10px";
    rulesContainer.style.borderLeft = "2px solid var(--background-modifier-border)";
    rulesContainer.createEl("h4", { text: "Rules (Processed in order)" });
    ruleset.rules.forEach((rule, ruleIndex) => {
      var _a;
      const ruleDiv = rulesContainer.createDiv("rule-item");
      ruleDiv.style.marginBottom = "10px";
      ruleDiv.style.padding = "10px";
      ruleDiv.style.backgroundColor = "var(--background-secondary)";
      ruleDiv.style.borderRadius = "4px";
      const ruleHeader = ruleDiv.createDiv("rule-header");
      ruleHeader.style.display = "flex";
      ruleHeader.style.justifyContent = "space-between";
      ruleHeader.style.alignItems = "center";
      ruleHeader.style.marginBottom = "10px";
      ruleHeader.createEl("span", { text: `Rule ${ruleIndex + 1}`, cls: "rule-title" });
      (_a = ruleHeader.querySelector(".rule-title")) == null ? void 0 : _a.setAttribute("style", "font-weight: bold;");
      new import_obsidian4.Setting(ruleHeader).addExtraButton((btn) => btn.setIcon("trash").setTooltip("Delete Rule").onClick(() => {
        ruleset.rules.splice(ruleIndex, 1);
        this.onUpdate(this.config);
        this.display();
      }));
      const querySetting = new import_obsidian4.Setting(ruleDiv);
      querySetting.setName("Condition (Dataview Query)");
      querySetting.setDesc("Leave empty to match all files.");
      querySetting.controlEl.style.width = "100%";
      const queryContainer = ruleDiv.createDiv();
      const textArea = queryContainer.createEl("textarea");
      textArea.style.width = "100%";
      textArea.style.minHeight = "60px";
      textArea.style.marginBottom = "10px";
      textArea.placeholder = 'FROM "folder" AND #tag';
      textArea.value = rule.query;
      textArea.onchange = (e) => {
        rule.query = e.target.value;
        this.onUpdate(this.config);
      };
      const actionsDiv = ruleDiv.createDiv("rule-actions");
      actionsDiv.createEl("h5", { text: "Actions" });
      rule.actions.forEach((action, actionIndex) => {
        const actionDiv = actionsDiv.createDiv("action-item");
        actionDiv.style.display = "flex";
        actionDiv.style.gap = "10px";
        actionDiv.style.alignItems = "center";
        actionDiv.style.marginBottom = "5px";
        const typeSelect = actionDiv.createEl("select");
        ["move", "rename", "tag"].forEach((t) => {
          const opt = typeSelect.createEl("option", { text: t, value: t });
          if (t === action.type)
            opt.selected = true;
        });
        typeSelect.onchange = () => {
          action.type = typeSelect.value;
          if (action.type === "move")
            action.config = { folder: "" };
          else if (action.type === "rename")
            action.config = { prefix: "", suffix: "" };
          else if (action.type === "tag")
            action.config = { tag: "", operation: "add" };
          this.onUpdate(this.config);
          this.display();
        };
        if (action.type === "move") {
          const folderInput = actionDiv.createEl("input", { type: "text" });
          folderInput.placeholder = "Folder Path";
          folderInput.value = action.config.folder || "";
          folderInput.onchange = () => {
            action.config.folder = folderInput.value;
            this.onUpdate(this.config);
          };
        } else if (action.type === "tag") {
          const tagInput = actionDiv.createEl("input", { type: "text" });
          tagInput.placeholder = "#tag";
          tagInput.value = action.config.tag || "";
          tagInput.onchange = () => {
            action.config.tag = tagInput.value;
            this.onUpdate(this.config);
          };
        }
        const deleteBtn = actionDiv.createEl("button", { text: "X" });
        deleteBtn.onclick = () => {
          rule.actions.splice(actionIndex, 1);
          this.onUpdate(this.config);
          this.display();
        };
      });
      const addActionBtn = actionsDiv.createEl("button", { text: "+ Add Action" });
      addActionBtn.onclick = () => {
        rule.actions.push({ type: "move", config: { folder: "" } });
        this.onUpdate(this.config);
        this.display();
      };
    });
    new import_obsidian4.Setting(rulesContainer).addButton((btn) => btn.setButtonText("Add Rule").onClick(() => {
      ruleset.rules.push({
        query: "",
        actions: []
      });
      this.onUpdate(this.config);
      this.display();
    }));
  }
  addRuleset() {
    const newRuleset = {
      id: crypto.randomUUID(),
      name: "New Ruleset",
      enabled: true,
      trigger: { type: "obsidian_event", event: "modify" },
      rules: []
    };
    this.config.rulesets.push(newRuleset);
    this.onUpdate(this.config);
    this.display();
  }
};

// ui/components/LogbookTab.ts
var import_obsidian5 = __toModule(require("obsidian"));
var LogbookTab = class {
  constructor(app, containerEl, binder) {
    this.app = app;
    this.containerEl = containerEl;
    this.binder = binder;
  }
  display() {
    this.containerEl.empty();
    const header = this.containerEl.createDiv("logbook-header");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "10px";
    const headerH3 = header.createEl("h3", { text: "Logbook" });
    headerH3.style.margin = "0";
    new import_obsidian5.ButtonComponent(header).setButtonText("Clear Log").setWarning().onClick(() => {
      this.binder.clear();
      this.display();
    });
    const entries = this.binder.getEntries();
    const logContainer = this.containerEl.createDiv("curator-logbook");
    logContainer.style.height = "400px";
    logContainer.style.overflowY = "auto";
    logContainer.style.border = "1px solid var(--background-modifier-border)";
    logContainer.style.padding = "10px";
    logContainer.style.borderRadius = "4px";
    logContainer.style.backgroundColor = "var(--background-primary)";
    logContainer.style.fontFamily = "monospace";
    if (entries.length === 0) {
      const emptyMsg = logContainer.createDiv({ text: "No entries found." });
      emptyMsg.style.color = "var(--text-muted)";
      emptyMsg.style.textAlign = "center";
      emptyMsg.style.padding = "20px";
      return;
    }
    entries.forEach((entry) => {
      const entryEl = logContainer.createDiv("curator-log-entry");
      entryEl.style.marginBottom = "4px";
      entryEl.style.borderBottom = "1px solid var(--background-modifier-border)";
      entryEl.style.paddingBottom = "4px";
      const timeSpan = entryEl.createSpan({ text: `[${new Date(entry.timestamp).toLocaleTimeString()}] `, cls: "curator-log-time" });
      timeSpan.style.color = "var(--text-muted)";
      const typeSpan = entryEl.createSpan({ text: entry.type.toUpperCase(), cls: `curator-log-type-${entry.type}` });
      typeSpan.style.fontWeight = "bold";
      typeSpan.style.marginRight = "5px";
      if (entry.type === "error")
        typeSpan.style.color = "var(--text-error)";
      else if (entry.type === "warning")
        typeSpan.style.color = "var(--text-warning)";
      else if (entry.type === "success")
        typeSpan.style.color = "var(--text-success)";
      else
        typeSpan.style.color = "var(--text-normal)";
      entryEl.createSpan({ text: `: ${entry.message}`, cls: "curator-log-message" });
      if (entry.relatedFile) {
        const fileSpan = entryEl.createSpan({ text: ` (${entry.relatedFile})`, cls: "curator-log-file" });
        fileSpan.style.color = "var(--text-accent)";
      }
    });
  }
};

// ui/CuratorSettingsTab.ts
var CuratorSettingsTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.activeTab = "rules";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Curator Settings" });
    const navContainer = containerEl.createDiv("curator-nav");
    navContainer.style.display = "flex";
    navContainer.style.gap = "10px";
    navContainer.style.marginBottom = "20px";
    this.createNavButton(navContainer, "Rules", "rules");
    this.createNavButton(navContainer, "Logbook", "logbook");
    const contentContainer = containerEl.createDiv("curator-content");
    if (this.activeTab === "rules") {
      new RulesTab(this.app, contentContainer, this.plugin.settings, (newConfig) => {
        this.plugin.settings = newConfig;
        this.plugin.saveSettings();
      }).display();
    } else if (this.activeTab === "logbook") {
      new LogbookTab(this.app, contentContainer, this.plugin.binder).display();
    }
  }
  createNavButton(container, text, tab) {
    const btn = container.createEl("button", { text });
    if (this.activeTab === tab) {
      btn.addClass("mod-cta");
    }
    btn.onclick = () => {
      this.activeTab = tab;
      this.display();
    };
  }
};

// main.ts
var AutoNoteMover = class extends import_obsidian7.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.binder = new BinderService(this.app);
      this.groupService = new GroupService(this.app);
      this.triggerService = new TriggerService(this.app);
      this.actionService = new ActionService(this.app, this.binder);
      this.rulesetService = new RulesetService(this.app, this.triggerService, this.groupService, this.binder, this.actionService);
      this.triggerService.initializeListeners();
      this.addSettingTab(new CuratorSettingsTab(this.app, this));
      this.rulesetService.updateConfig(this.settings);
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => {
          this.triggerService.handleSystemEvent("startup");
        }, 2e3);
      });
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      const DEFAULT_SETTINGS = {
        rulesets: []
      };
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      if (this.rulesetService) {
        this.rulesetService.updateConfig(this.settings);
      }
    });
  }
};
