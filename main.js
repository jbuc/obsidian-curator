/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// core/BinderService.ts
var BinderService_exports = {};
__export(BinderService_exports, {
  BinderService: () => BinderService
});
var BinderService;
var init_BinderService = __esm({
  "core/BinderService.ts"() {
    BinderService = class {
      constructor(app) {
        this.app = app;
        this.state = {
          entries: []
        };
      }
      log(type, message, relatedFile, details) {
        const entry = {
          id: crypto.randomUUID(),
          timestamp: Date.now(),
          type,
          message,
          relatedFile,
          details
        };
        this.state.entries.unshift(entry);
        if (this.state.entries.length > 1e3) {
          this.state.entries = this.state.entries.slice(0, 1e3);
        }
      }
      getEntries() {
        return this.state.entries;
      }
      clear() {
        this.state.entries = [];
      }
    };
  }
});

// core/GroupService.ts
var GroupService_exports = {};
__export(GroupService_exports, {
  GroupService: () => GroupService
});
var import_obsidian, GroupService;
var init_GroupService = __esm({
  "core/GroupService.ts"() {
    import_obsidian = __toModule(require("obsidian"));
    GroupService = class {
      constructor(app) {
        this.app = app;
      }
      isInGroup(file, group) {
        return __async(this, null, function* () {
          const matchingFiles = yield this.getMatchingFiles(group);
          return matchingFiles.some((f) => f.path === file.path);
        });
      }
      getMatchingFiles(group) {
        return __async(this, null, function* () {
          var _a, _b, _c;
          if (!group.query || group.query.trim() === "") {
            return [];
          }
          const dataviewAPI = (_c = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b.dataview) == null ? void 0 : _c.api;
          if (!dataviewAPI) {
            console.warn("[Curator] Dataview plugin not found or API not available.");
            return [];
          }
          try {
            let dql = group.query.trim();
            if (!/^(TABLE|LIST|TASK|CALENDAR)/i.test(dql)) {
              dql = `LIST ${dql}`;
            }
            const result = yield dataviewAPI.query(dql);
            if (!result.successful) {
              console.warn(`[Curator] Dataview query failed for group ${group.name}: ${result.error}`);
              return [];
            }
            const values = result.value.values;
            const matchingFiles = [];
            for (const item of values) {
              let path;
              if (item && item.path) {
                path = item.path;
              } else if (item && item.file && item.file.path) {
                path = item.file.path;
              }
              if (path) {
                const file = this.app.vault.getAbstractFileByPath(path);
                if (file instanceof import_obsidian.TFile) {
                  matchingFiles.push(file);
                }
              }
            }
            return matchingFiles;
          } catch (error) {
            console.error(`[Curator] Error executing Dataview query for group ${group.name}:`, error);
            return [];
          }
        });
      }
      matchesQuery(file, query) {
        return __async(this, null, function* () {
          const tempGroup = { id: "temp", name: "temp", query };
          const matchingFiles = yield this.getMatchingFiles(tempGroup);
          return matchingFiles.some((f) => f.path === file.path);
        });
      }
      updateIdentifiers(identifiers) {
      }
    };
  }
});

// core/TriggerService.ts
var TriggerService_exports = {};
__export(TriggerService_exports, {
  TriggerService: () => TriggerService
});
var import_obsidian2, TriggerService;
var init_TriggerService = __esm({
  "core/TriggerService.ts"() {
    import_obsidian2 = __toModule(require("obsidian"));
    TriggerService = class {
      constructor(app) {
        this.listeners = new Map();
        this.eventRefs = [];
        this.activeTriggers = new Map();
        this.intervals = [];
        this.lastActiveFile = null;
        this.dirtyFiles = new Set();
        this.app = app;
      }
      registerTrigger(id, trigger, callback) {
        var _a;
        console.log(`[DEBUG] Registering trigger ${id}`);
        if (!this.listeners.has(id)) {
          this.listeners.set(id, []);
        }
        (_a = this.listeners.get(id)) == null ? void 0 : _a.push(callback);
        this.activeTriggers.set(id, trigger);
        if (trigger.type === "interval" || trigger.type === "schedule") {
          this.registerTimeEvent(id, trigger);
        } else if (trigger.type === "manual") {
          this.registerManualCommand(id, trigger);
        }
      }
      clearTriggers() {
        this.listeners.clear();
        this.activeTriggers.clear();
        this.intervals.forEach((id) => window.clearInterval(id));
        this.intervals = [];
      }
      initializeListeners() {
        this.eventRefs.forEach((ref) => this.app.vault.offref(ref));
        this.eventRefs = [];
        this.eventRefs.push(this.app.vault.on("create", (file) => {
          if (file instanceof import_obsidian2.TFile)
            this.handleEvent("create", file);
        }));
        this.eventRefs.push(this.app.vault.on("modify", (file) => {
          if (file instanceof import_obsidian2.TFile)
            this.handleEvent("modify", file);
        }));
        this.eventRefs.push(this.app.vault.on("rename", (file, oldPath) => {
          if (file instanceof import_obsidian2.TFile)
            this.handleEvent("rename", file, oldPath);
        }));
        this.eventRefs.push(this.app.vault.on("delete", (file) => {
          if (file instanceof import_obsidian2.TFile)
            this.handleEvent("delete", file);
        }));
        this.app.workspace.onLayoutReady(() => {
          this.lastActiveFile = this.app.workspace.getActiveFile();
        });
        this.eventRefs.push(this.app.workspace.on("active-leaf-change", () => {
          const currentFile = this.app.workspace.getActiveFile();
          if (this.lastActiveFile && this.lastActiveFile !== currentFile) {
            if (this.dirtyFiles.has(this.lastActiveFile.path)) {
              for (const [id, trigger] of this.activeTriggers.entries()) {
                if (trigger.type === "change_from" || trigger.type === "change_to") {
                  this.fireTrigger(id, this.lastActiveFile);
                }
              }
              this.dirtyFiles.delete(this.lastActiveFile.path);
            }
          }
          this.lastActiveFile = currentFile;
        }));
        this.startSyncPolling();
      }
      startSyncPolling() {
      }
      handleEvent(eventType, file, oldPath) {
        if (eventType === "modify") {
          this.dirtyFiles.add(file.path);
          return;
        }
        if (eventType === "create" || eventType === "rename") {
          for (const [id, trigger] of this.activeTriggers.entries()) {
            if (trigger.type === "change_to") {
              this.fireTrigger(id, file);
            }
          }
        }
      }
      handleSystemEvent(eventType) {
        return __async(this, null, function* () {
          const files = this.app.vault.getMarkdownFiles();
          for (const [id, trigger] of this.activeTriggers.entries()) {
            if (trigger.type === "startup") {
              for (const file of files) {
                this.fireTrigger(id, file);
              }
            }
          }
        });
      }
      registerTimeEvent(id, trigger) {
        if (trigger.type === "interval" && trigger.interval) {
          const intervalMs = trigger.interval * 60 * 1e3;
          const intervalId = window.setInterval(() => {
            const files = this.app.vault.getMarkdownFiles();
            files.forEach((file) => this.fireTrigger(id, file));
          }, intervalMs);
          this.intervals.push(intervalId);
        } else if (trigger.type === "schedule" && trigger.time) {
        }
      }
      registerManualCommand(id, trigger) {
        if (trigger.commandName) {
          const commandId = `curator-manual-${id}`;
          this.app.addCommand({
            id: commandId,
            name: trigger.commandName,
            callback: () => {
              const activeFile = this.app.workspace.getActiveFile();
              if (activeFile) {
                this.fireTrigger(id, activeFile);
              } else {
                new import_obsidian2.Notice("No active file to run Curator on.");
              }
            }
          });
        }
      }
      fireTrigger(triggerId, file) {
        const callbacks = this.listeners.get(triggerId);
        if (callbacks) {
          callbacks.forEach((cb) => cb(triggerId, file));
        }
      }
      unload() {
        this.eventRefs.forEach((ref) => this.app.vault.offref(ref));
        this.eventRefs = [];
        this.listeners.clear();
        this.activeTriggers.clear();
      }
    };
  }
});

// core/ActionService.ts
var ActionService_exports = {};
__export(ActionService_exports, {
  ActionService: () => ActionService
});
var import_obsidian3, ActionService;
var init_ActionService = __esm({
  "core/ActionService.ts"() {
    import_obsidian3 = __toModule(require("obsidian"));
    ActionService = class {
      constructor(app, binder) {
        this.app = app;
        this.binder = binder;
      }
      executeAction(file, action) {
        return __async(this, null, function* () {
          try {
            switch (action.type) {
              case "move":
                if (action.config.folder) {
                  yield this.moveFile(file, { folder: action.config.folder, createIfMissing: action.config.createIfMissing });
                }
                break;
              case "rename":
                yield this.renameFile(file, action.config);
                break;
              case "tag":
                if (action.config.tag) {
                  yield this.tagFile(file, { tag: action.config.tag, operation: action.config.operation || "add" });
                }
                break;
              case "update":
                if (action.config.key) {
                  yield this.updateFrontmatter(file, { key: action.config.key, value: action.config.value || "" });
                }
                break;
              default:
                this.binder.log("warning", `Unknown action type: ${action.type}`, file.path);
            }
          } catch (error) {
            this.binder.log("error", `Failed to execute action ${action.type}`, file.path, error);
            throw error;
          }
        });
      }
      moveFile(file, config) {
        return __async(this, null, function* () {
          let targetFolder = (0, import_obsidian3.normalizePath)(config.folder);
          const folderExists = yield this.app.vault.adapter.exists(targetFolder);
          if (!folderExists) {
            if (config.createIfMissing) {
              yield this.app.vault.createFolder(targetFolder);
              this.binder.log("info", `Created folder ${targetFolder}`);
            } else {
              this.binder.log("error", `Target folder ${targetFolder} does not exist`, file.path);
              return;
            }
          }
          const targetPath = (0, import_obsidian3.normalizePath)(`${targetFolder}/${file.name}`);
          if (targetPath === file.path) {
            return;
          }
          const targetFileExists = yield this.app.vault.adapter.exists(targetPath);
          if (targetFileExists) {
            this.binder.log("warning", `File ${targetPath} already exists. Skipping move.`, file.path);
            return;
          }
          yield this.app.fileManager.renameFile(file, targetPath);
          this.binder.log("success", `Moved file to ${targetFolder}`, targetPath);
        });
      }
      renameFile(file, config) {
        return __async(this, null, function* () {
          var _a;
          let newName = file.basename;
          if (config.replace) {
            newName = config.replace;
          }
          if (config.prefix) {
            newName = `${config.prefix}${newName}`;
          }
          if (config.suffix) {
            newName = `${newName}${config.suffix}`;
          }
          if (newName === file.basename)
            return;
          const targetPath = (0, import_obsidian3.normalizePath)(`${(_a = file.parent) == null ? void 0 : _a.path}/${newName}.${file.extension}`);
          if (yield this.app.vault.adapter.exists(targetPath)) {
            this.binder.log("warning", `File ${targetPath} already exists. Skipping rename.`, file.path);
            return;
          }
          yield this.app.fileManager.renameFile(file, targetPath);
          this.binder.log("success", `Renamed file to ${newName}`, targetPath);
        });
      }
      tagFile(file, config) {
        return __async(this, null, function* () {
          yield this.app.fileManager.processFrontmatter(file, (frontmatter) => {
            let tags = frontmatter["tags"];
            if (!tags)
              tags = [];
            if (!Array.isArray(tags))
              tags = [tags];
            const targetTag = config.tag.startsWith("#") ? config.tag.substring(1) : config.tag;
            if (config.operation === "add") {
              if (!tags.includes(targetTag)) {
                tags.push(targetTag);
                this.binder.log("success", `Added tag #${targetTag}`, file.path);
              }
            } else if (config.operation === "remove") {
              const index = tags.indexOf(targetTag);
              if (index > -1) {
                tags.splice(index, 1);
                this.binder.log("success", `Removed tag #${targetTag}`, file.path);
              }
            }
            frontmatter["tags"] = tags;
          });
        });
      }
      updateFrontmatter(file, config) {
        return __async(this, null, function* () {
          yield this.app.fileManager.processFrontmatter(file, (frontmatter) => {
            if (config.key) {
              frontmatter[config.key] = config.value;
              this.binder.log("success", `Updated frontmatter: ${config.key} = ${config.value}`, file.path);
            }
          });
        });
      }
    };
  }
});

// core/RulesetService.ts
var RulesetService_exports = {};
__export(RulesetService_exports, {
  RulesetService: () => RulesetService
});
var RulesetService;
var init_RulesetService = __esm({
  "core/RulesetService.ts"() {
    RulesetService = class {
      constructor(app, triggerService, groupService, binder, actionService) {
        this.rulesets = [];
        this.app = app;
        this.triggerService = triggerService;
        this.groupService = groupService;
        this.binder = binder;
        this.actionService = actionService;
      }
      updateConfig(config) {
        this.rulesets = config.rulesets;
        this.triggerService.clearTriggers();
        this.rulesets.forEach((ruleset) => {
          if (ruleset.enabled && ruleset.trigger) {
            this.triggerService.registerTrigger(ruleset.id, ruleset.trigger, (triggerId, file) => {
              this.handleTrigger(triggerId, file);
            });
          }
        });
      }
      handleTrigger(rulesetId, file) {
        return __async(this, null, function* () {
          const ruleset = this.rulesets.find((r) => r.id === rulesetId);
          if (!ruleset || !ruleset.enabled)
            return;
          this.binder.log("info", `Processing Ruleset: ${ruleset.name}`, file.path);
          if (ruleset.trigger.query && ruleset.trigger.query.trim() !== "") {
            const matchesScope = yield this.groupService.matchesQuery(file, ruleset.trigger.query);
            if (!matchesScope) {
              this.binder.log("info", `File did not match trigger scope. Skipping.`, file.path);
              return;
            }
          }
          for (const rule of ruleset.rules) {
            let match = true;
            if (rule.query && rule.query.trim() !== "") {
              const tempGroup = { id: "temp", name: "Rule Query", query: rule.query };
              match = yield this.groupService.isInGroup(file, tempGroup);
            } else {
              match = true;
            }
            if (match) {
              this.binder.log("info", `Rule matched. Executing actions.`, file.path);
              yield this.executeActions(rule.actions, file);
            }
          }
        });
      }
      executeActions(actions, file) {
        return __async(this, null, function* () {
          for (const action of actions) {
            try {
              yield this.actionService.executeAction(file, action);
            } catch (error) {
              this.binder.log("error", `Failed to execute action ${action.type}`, file.path, error);
            }
          }
        });
      }
      dryRun(rulesetId) {
        return __async(this, null, function* () {
          const ruleset = this.rulesets.find((r) => r.id === rulesetId);
          if (!ruleset)
            return [];
          const results = [];
          const files = this.app.vault.getMarkdownFiles();
          for (const file of files) {
            const fileActions = [];
            for (const rule of ruleset.rules) {
              let match = true;
              if (rule.query && rule.query.trim() !== "") {
                const tempGroup = { id: "temp", name: "Rule Query", query: rule.query };
                match = yield this.groupService.isInGroup(file, tempGroup);
              }
              if (match) {
                for (const action of rule.actions) {
                  fileActions.push(`${action.type} ${JSON.stringify(action.config)}`);
                }
              }
            }
            if (fileActions.length > 0) {
              results.push({ file, actions: fileActions });
            }
          }
          return results;
        });
      }
    };
  }
});

// main.ts
__export(exports, {
  default: () => AutoNoteMover
});
var import_obsidian8 = __toModule(require("obsidian"));
init_BinderService();
init_GroupService();
init_TriggerService();
init_ActionService();
init_RulesetService();

// ui/CuratorSettingsTab.ts
var import_obsidian7 = __toModule(require("obsidian"));

// ui/components/RulesTab.ts
var import_obsidian5 = __toModule(require("obsidian"));

// ui/components/FolderSuggest.ts
var import_obsidian4 = __toModule(require("obsidian"));
var FolderSuggest = class {
  constructor(app, inputEl) {
    this.app = app;
    this.inputEl = inputEl;
    this.suggestions = [];
    this.isOpen = false;
    this.selectedIndex = -1;
    this.containerEl = createDiv("suggestion-container");
    this.containerEl.style.position = "absolute";
    this.containerEl.style.zIndex = "1000";
    this.containerEl.style.display = "none";
    this.containerEl.style.maxHeight = "200px";
    this.containerEl.style.overflowY = "auto";
    this.containerEl.style.backgroundColor = "var(--background-secondary)";
    this.containerEl.style.border = "1px solid var(--background-modifier-border)";
    document.body.appendChild(this.containerEl);
    this.inputEl.addEventListener("input", this.onInput.bind(this));
    this.inputEl.addEventListener("blur", () => setTimeout(() => this.close(), 200));
    this.inputEl.addEventListener("focus", this.onInput.bind(this));
    this.inputEl.addEventListener("keydown", this.onKeyDown.bind(this));
  }
  onInput() {
    const val = this.inputEl.value;
    this.suggestions = this.getSuggestions(val);
    this.selectedIndex = -1;
    if (this.suggestions.length > 0) {
      this.open();
      this.renderSuggestions();
    } else {
      this.close();
    }
  }
  onKeyDown(e) {
    if (!this.isOpen || this.suggestions.length === 0)
      return;
    if (e.key === "ArrowDown") {
      e.preventDefault();
      this.selectedIndex = (this.selectedIndex + 1) % this.suggestions.length;
      this.renderSuggestions();
      this.scrollIntoView();
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      this.selectedIndex = (this.selectedIndex - 1 + this.suggestions.length) % this.suggestions.length;
      this.renderSuggestions();
      this.scrollIntoView();
    } else if (e.key === "Enter") {
      if (this.selectedIndex >= 0 && this.selectedIndex < this.suggestions.length) {
        e.preventDefault();
        this.selectSuggestion(this.suggestions[this.selectedIndex]);
      }
    } else if (e.key === "Escape") {
      this.close();
    }
  }
  scrollIntoView() {
    const selectedEl = this.containerEl.children[this.selectedIndex];
    if (selectedEl) {
      selectedEl.scrollIntoView({ block: "nearest" });
    }
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((file) => {
      if (file instanceof import_obsidian4.TFolder) {
        if (file.path.toLowerCase().contains(lowerCaseInputStr)) {
          folders.push(file);
        }
      }
    });
    return folders;
  }
  renderSuggestions() {
    this.containerEl.empty();
    const rect = this.inputEl.getBoundingClientRect();
    this.containerEl.style.top = `${rect.bottom}px`;
    this.containerEl.style.left = `${rect.left}px`;
    this.containerEl.style.width = `${rect.width}px`;
    this.suggestions.forEach((folder, index) => {
      const item = this.containerEl.createDiv("suggestion-item");
      item.setText(folder.path);
      item.style.padding = "5px";
      item.style.cursor = "pointer";
      if (index === this.selectedIndex) {
        item.style.backgroundColor = "var(--background-modifier-hover)";
        item.addClass("is-selected");
      }
      item.addEventListener("mouseenter", () => {
        this.selectedIndex = index;
        this.renderSuggestions();
      });
      item.addEventListener("mousedown", (e) => {
        e.preventDefault();
        this.selectSuggestion(folder);
      });
    });
  }
  selectSuggestion(folder) {
    this.inputEl.value = folder.path;
    this.inputEl.trigger("input");
    this.close();
  }
  open() {
    this.containerEl.style.display = "block";
    this.isOpen = true;
  }
  close() {
    this.containerEl.style.display = "none";
    this.isOpen = false;
    this.selectedIndex = -1;
  }
};

// ui/components/RulesTab.ts
var RulesTab = class {
  constructor(app, containerEl, config, onUpdate) {
    this.app = app;
    this.containerEl = containerEl;
    this.config = config;
    this.onUpdate = onUpdate;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.createEl("h3", { text: "Rules Configuration" });
    this.containerEl.createEl("p", { text: "Connect Triggers, Groups, and Jobs to create automated workflows." });
    new import_obsidian5.Setting(this.containerEl).setName("Add New Ruleset").setDesc("Create a new rule to automate your notes.").addButton((button) => button.setButtonText("Add Ruleset").setCta().onClick(() => {
      this.addRuleset();
    }));
    const rulesetsList = this.containerEl.createDiv("rulesets-list");
    this.config.rulesets.forEach((ruleset, index) => {
      this.renderRuleset(rulesetsList, ruleset, index);
    });
  }
  addRuleset() {
    const newRuleset = {
      id: crypto.randomUUID(),
      name: "New Ruleset",
      enabled: true,
      trigger: { type: "change_to", query: "" },
      rules: []
    };
    this.config.rulesets.push(newRuleset);
    this.onUpdate(this.config);
    this.display();
  }
  renderRuleset(container, ruleset, index) {
    const rulesetContainer = container.createDiv("ruleset-container");
    rulesetContainer.style.border = "1px solid var(--background-modifier-border)";
    rulesetContainer.style.padding = "10px";
    rulesetContainer.style.marginBottom = "10px";
    rulesetContainer.style.borderRadius = "4px";
    new import_obsidian5.Setting(rulesetContainer).setName("Ruleset Name").addText((text) => text.setValue(ruleset.name).onChange((value) => {
      ruleset.name = value;
      this.onUpdate(this.config);
    })).addToggle((toggle) => toggle.setValue(ruleset.enabled).setTooltip("Enable/Disable Ruleset").onChange((value) => {
      ruleset.enabled = value;
      this.onUpdate(this.config);
    })).addExtraButton((btn) => btn.setIcon("trash").setTooltip("Delete Ruleset").onClick(() => {
      this.config.rulesets.splice(index, 1);
      this.onUpdate(this.config);
      this.display();
    }));
    const triggerDiv = rulesetContainer.createDiv("trigger-config");
    triggerDiv.style.marginBottom = "10px";
    triggerDiv.style.padding = "10px";
    triggerDiv.style.backgroundColor = "var(--background-primary-alt)";
    triggerDiv.style.borderRadius = "4px";
    new import_obsidian5.Setting(triggerDiv).setName("Trigger Type").addDropdown((dropdown) => dropdown.addOption("change_from", "Notes change from...").addOption("change_to", "Notes change to...").addOption("startup", "Obsidian starts").addOption("interval", "An interval occurs").addOption("schedule", "A date/time passes").addOption("manual", "A command runs").setValue(ruleset.trigger.type).onChange((value) => {
      ruleset.trigger.type = value;
      if (ruleset.trigger.type === "interval")
        ruleset.trigger.interval = 5;
      else if (ruleset.trigger.type === "manual")
        ruleset.trigger.commandName = "Run My Rule";
      this.onUpdate(this.config);
      this.display();
    }));
    if (ruleset.trigger.type === "change_from" || ruleset.trigger.type === "change_to") {
      new import_obsidian5.Setting(triggerDiv).setName("Dataview Query").setDesc("Define the set of notes to monitor.").addTextArea((text) => {
        text.setPlaceholder('FROM "projects" AND #active').setValue(ruleset.trigger.query || "");
        text.inputEl.oninput = (e) => {
          ruleset.trigger.query = e.target.value;
          this.onUpdate(this.config);
        };
      });
    } else if (ruleset.trigger.type === "interval") {
      new import_obsidian5.Setting(triggerDiv).setName("Interval (Minutes)").addText((text) => text.setValue(String(ruleset.trigger.interval || 5)).onChange((value) => {
        ruleset.trigger.interval = Number(value);
        this.onUpdate(this.config);
      }));
    } else if (ruleset.trigger.type === "schedule") {
      new import_obsidian5.Setting(triggerDiv).setName("Time (HH:mm)").setDesc("Run daily at this time.").addText((text) => text.setPlaceholder("09:00").setValue(ruleset.trigger.time || "").onChange((value) => {
        ruleset.trigger.time = value;
        this.onUpdate(this.config);
      }));
    } else if (ruleset.trigger.type === "manual") {
      new import_obsidian5.Setting(triggerDiv).setName("Command Name").setDesc("Name of the command in Command Palette").addText((text) => text.setValue(ruleset.trigger.commandName || "").onChange((value) => {
        ruleset.trigger.commandName = value;
        this.onUpdate(this.config);
      }));
    }
    new import_obsidian5.Setting(rulesetContainer).addButton((btn) => btn.setButtonText("Test Run (Dry Run)").setTooltip("Simulate this ruleset on all files to see what would happen.").onClick(() => __async(this, null, function* () {
      const { RulesetService: RulesetService2 } = yield Promise.resolve().then(() => (init_RulesetService(), RulesetService_exports));
      const { GroupService: GroupService2 } = yield Promise.resolve().then(() => (init_GroupService(), GroupService_exports));
      const { TriggerService: TriggerService2 } = yield Promise.resolve().then(() => (init_TriggerService(), TriggerService_exports));
      const { BinderService: BinderService2 } = yield Promise.resolve().then(() => (init_BinderService(), BinderService_exports));
      const { ActionService: ActionService2 } = yield Promise.resolve().then(() => (init_ActionService(), ActionService_exports));
      const binder = new BinderService2(this.app);
      const groupService = new GroupService2(this.app);
      const triggerService = new TriggerService2(this.app);
      const actionService = new ActionService2(this.app, binder);
      const rulesetService = new RulesetService2(this.app, triggerService, groupService, binder, actionService);
      rulesetService.updateConfig(this.config);
      const results = yield rulesetService.dryRun(ruleset.id);
      const modal = new import_obsidian5.Modal(this.app);
      modal.titleEl.setText(`Dry Run: ${ruleset.name}`);
      if (results.length === 0) {
        modal.contentEl.createEl("p", { text: "No files matched the criteria." });
      } else {
        modal.contentEl.createEl("p", { text: `Found ${results.length} matches:` });
        const list = modal.contentEl.createEl("div");
        list.style.maxHeight = "400px";
        list.style.overflowY = "auto";
        results.forEach((r) => {
          const item = list.createDiv();
          item.style.marginBottom = "5px";
          item.style.borderBottom = "1px solid var(--background-modifier-border)";
          item.createEl("strong", { text: r.file.path });
          const actionsList = item.createEl("ul");
          r.actions.forEach((a) => actionsList.createEl("li", { text: `Action: ${a}` }));
        });
      }
      modal.open();
    })));
    const rulesContainer = rulesetContainer.createDiv("rules-container");
    rulesContainer.style.marginTop = "10px";
    rulesContainer.style.paddingLeft = "10px";
    rulesContainer.style.borderLeft = "2px solid var(--background-modifier-border)";
    rulesContainer.createEl("h4", { text: "Rules (Processed in order)" });
    ruleset.rules.forEach((rule, ruleIndex) => {
      var _a;
      const ruleDiv = rulesContainer.createDiv("rule-item");
      ruleDiv.style.marginBottom = "10px";
      ruleDiv.style.padding = "10px";
      ruleDiv.style.backgroundColor = "var(--background-secondary)";
      ruleDiv.style.borderRadius = "4px";
      const ruleHeader = ruleDiv.createDiv("rule-header");
      ruleHeader.style.display = "flex";
      ruleHeader.style.justifyContent = "space-between";
      ruleHeader.style.alignItems = "center";
      ruleHeader.style.marginBottom = "10px";
      ruleHeader.createEl("span", { text: `Rule ${ruleIndex + 1}`, cls: "rule-title" });
      (_a = ruleHeader.querySelector(".rule-title")) == null ? void 0 : _a.setAttribute("style", "font-weight: bold;");
      new import_obsidian5.Setting(ruleHeader).addExtraButton((btn) => btn.setIcon("trash").setTooltip("Delete Rule").onClick(() => {
        ruleset.rules.splice(ruleIndex, 1);
        this.onUpdate(this.config);
        this.display();
      }));
      const querySetting = new import_obsidian5.Setting(ruleDiv);
      querySetting.setName("Condition (Dataview Query)");
      querySetting.setDesc("Leave empty to match all files.");
      querySetting.controlEl.style.width = "100%";
      const queryContainer = ruleDiv.createDiv();
      const textArea = queryContainer.createEl("textarea");
      textArea.style.width = "100%";
      textArea.style.minHeight = "60px";
      textArea.style.marginBottom = "10px";
      textArea.placeholder = 'FROM "folder" AND #tag';
      textArea.value = rule.query;
      textArea.oninput = (e) => {
        rule.query = e.target.value;
        this.onUpdate(this.config);
      };
      const actionsDiv = ruleDiv.createDiv("rule-actions");
      actionsDiv.createEl("h5", { text: "Actions" });
      rule.actions.forEach((action, actionIndex) => {
        const actionDiv = actionsDiv.createDiv("action-item");
        actionDiv.style.display = "flex";
        actionDiv.style.gap = "10px";
        actionDiv.style.alignItems = "center";
        actionDiv.style.marginBottom = "5px";
        actionDiv.style.flexWrap = "wrap";
        const typeSelect = actionDiv.createEl("select");
        ["move", "rename", "tag", "update"].forEach((t) => {
          const opt = typeSelect.createEl("option", { text: t, value: t });
          if (t === action.type)
            opt.selected = true;
        });
        typeSelect.onchange = () => {
          action.type = typeSelect.value;
          if (action.type === "move")
            action.config = { folder: "" };
          else if (action.type === "rename")
            action.config = { prefix: "", suffix: "" };
          else if (action.type === "tag")
            action.config = { tag: "", operation: "add" };
          else if (action.type === "update")
            action.config = { key: "", value: "" };
          this.onUpdate(this.config);
          this.display();
        };
        if (action.type === "move") {
          const folderInput = actionDiv.createEl("input", { type: "text" });
          folderInput.placeholder = "Folder Path";
          folderInput.value = action.config.folder || "";
          new FolderSuggest(this.app, folderInput);
          folderInput.oninput = () => {
            action.config.folder = folderInput.value;
            this.onUpdate(this.config);
          };
        } else if (action.type === "tag") {
          const tagInput = actionDiv.createEl("input", { type: "text" });
          tagInput.placeholder = "#tag";
          tagInput.value = action.config.tag || "";
          tagInput.oninput = () => {
            action.config.tag = tagInput.value;
            this.onUpdate(this.config);
          };
          const opSelect = actionDiv.createEl("select");
          ["add", "remove"].forEach((op) => {
            const opt = opSelect.createEl("option", { text: op, value: op });
            if (op === action.config.operation)
              opt.selected = true;
          });
          opSelect.onchange = () => {
            action.config.operation = opSelect.value;
            this.onUpdate(this.config);
          };
        } else if (action.type === "update") {
          const keyInput = actionDiv.createEl("input", { type: "text" });
          keyInput.placeholder = "Property Key";
          keyInput.value = action.config.key || "";
          keyInput.oninput = () => {
            action.config.key = keyInput.value;
            this.onUpdate(this.config);
          };
          const valInput = actionDiv.createEl("input", { type: "text" });
          valInput.placeholder = "Value";
          valInput.value = action.config.value || "";
          valInput.oninput = () => {
            action.config.value = valInput.value;
            this.onUpdate(this.config);
          };
        } else if (action.type === "rename") {
          const prefixInput = actionDiv.createEl("input", { type: "text" });
          prefixInput.placeholder = "Prefix";
          prefixInput.value = action.config.prefix || "";
          prefixInput.oninput = () => {
            action.config.prefix = prefixInput.value;
            this.onUpdate(this.config);
          };
          const suffixInput = actionDiv.createEl("input", { type: "text" });
          suffixInput.placeholder = "Suffix";
          suffixInput.value = action.config.suffix || "";
          suffixInput.oninput = () => {
            action.config.suffix = suffixInput.value;
            this.onUpdate(this.config);
          };
        }
        const deleteBtn = actionDiv.createEl("button", { text: "X" });
        deleteBtn.onclick = () => {
          rule.actions.splice(actionIndex, 1);
          this.onUpdate(this.config);
          this.display();
        };
      });
      const addActionBtn = actionsDiv.createEl("button", { text: "+ Add Action" });
      addActionBtn.onclick = () => {
        rule.actions.push({ type: "move", config: { folder: "" } });
        this.onUpdate(this.config);
        this.display();
      };
    });
    new import_obsidian5.Setting(rulesContainer).addButton((btn) => btn.setButtonText("Add Rule").onClick(() => {
      ruleset.rules.push({
        query: "",
        actions: []
      });
      this.onUpdate(this.config);
      this.display();
    }));
  }
};

// ui/components/LogbookTab.ts
var import_obsidian6 = __toModule(require("obsidian"));
var LogbookTab = class {
  constructor(app, containerEl, binder) {
    this.app = app;
    this.containerEl = containerEl;
    this.binder = binder;
  }
  display() {
    this.containerEl.empty();
    const header = this.containerEl.createDiv("logbook-header");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "10px";
    const headerH3 = header.createEl("h3", { text: "Logbook" });
    headerH3.style.margin = "0";
    new import_obsidian6.ButtonComponent(header).setButtonText("Clear Log").setWarning().onClick(() => {
      this.binder.clear();
      this.display();
    });
    const entries = this.binder.getEntries();
    const logContainer = this.containerEl.createDiv("curator-logbook");
    logContainer.style.height = "400px";
    logContainer.style.overflowY = "auto";
    logContainer.style.border = "1px solid var(--background-modifier-border)";
    logContainer.style.padding = "10px";
    logContainer.style.borderRadius = "4px";
    logContainer.style.backgroundColor = "var(--background-primary)";
    logContainer.style.fontFamily = "monospace";
    if (entries.length === 0) {
      const emptyMsg = logContainer.createDiv({ text: "No entries found." });
      emptyMsg.style.color = "var(--text-muted)";
      emptyMsg.style.textAlign = "center";
      emptyMsg.style.padding = "20px";
      return;
    }
    entries.forEach((entry) => {
      const entryEl = logContainer.createDiv("curator-log-entry");
      entryEl.style.marginBottom = "4px";
      entryEl.style.borderBottom = "1px solid var(--background-modifier-border)";
      entryEl.style.paddingBottom = "4px";
      const timeSpan = entryEl.createSpan({ text: `[${new Date(entry.timestamp).toLocaleTimeString()}] `, cls: "curator-log-time" });
      timeSpan.style.color = "var(--text-muted)";
      const typeSpan = entryEl.createSpan({ text: entry.type.toUpperCase(), cls: `curator-log-type-${entry.type}` });
      typeSpan.style.fontWeight = "bold";
      typeSpan.style.marginRight = "5px";
      if (entry.type === "error")
        typeSpan.style.color = "var(--text-error)";
      else if (entry.type === "warning")
        typeSpan.style.color = "var(--text-warning)";
      else if (entry.type === "success")
        typeSpan.style.color = "var(--text-success)";
      else
        typeSpan.style.color = "var(--text-normal)";
      entryEl.createSpan({ text: `: ${entry.message}`, cls: "curator-log-message" });
      if (entry.relatedFile) {
        const fileSpan = entryEl.createSpan({ text: ` (${entry.relatedFile})`, cls: "curator-log-file" });
        fileSpan.style.color = "var(--text-accent)";
      }
    });
  }
};

// ui/CuratorSettingsTab.ts
var CuratorSettingsTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.activeTab = "rules";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Curator Settings" });
    const navContainer = containerEl.createDiv("curator-nav");
    navContainer.style.display = "flex";
    navContainer.style.gap = "10px";
    navContainer.style.marginBottom = "20px";
    this.createNavButton(navContainer, "Rules", "rules");
    this.createNavButton(navContainer, "Logbook", "logbook");
    const contentContainer = containerEl.createDiv("curator-content");
    if (this.activeTab === "rules") {
      new RulesTab(this.app, contentContainer, this.plugin.settings, (newConfig) => {
        this.plugin.settings = newConfig;
        this.plugin.saveSettings();
      }).display();
    } else if (this.activeTab === "logbook") {
      new LogbookTab(this.app, contentContainer, this.plugin.binder).display();
    }
  }
  createNavButton(container, text, tab) {
    const btn = container.createEl("button", { text });
    if (this.activeTab === tab) {
      btn.addClass("mod-cta");
    }
    btn.onclick = () => {
      this.activeTab = tab;
      this.display();
    };
  }
};

// main.ts
var AutoNoteMover = class extends import_obsidian8.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.binder = new BinderService(this.app);
      this.groupService = new GroupService(this.app);
      this.triggerService = new TriggerService(this.app);
      this.actionService = new ActionService(this.app, this.binder);
      this.rulesetService = new RulesetService(this.app, this.triggerService, this.groupService, this.binder, this.actionService);
      this.triggerService.initializeListeners();
      this.addSettingTab(new CuratorSettingsTab(this.app, this));
      this.rulesetService.updateConfig(this.settings);
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => {
          this.triggerService.handleSystemEvent("startup");
        }, 2e3);
      });
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      const DEFAULT_SETTINGS = {
        rulesets: []
      };
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      if (this.rulesetService) {
        this.rulesetService.updateConfig(this.settings);
      }
    });
  }
};
